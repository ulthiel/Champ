/*
	CHAMP (CHerednik Algebra Magma Package)
	Copyright (C) 2010-2021 Ulrich Thiel
	Licensed under GNU GPLv3, see COPYING.
	thiel@mathematik.uni-kl.de
	https://ulthiel.com/math
*/

/*
    Intrinsics for fake degrees of matrix groups. If G is a finite matrix group acting on a vector space V over a field K, then the coinvariant algebra is the quotient of the coordinate algebra K[V] by the ideal generated by the invariants K[V]^G_+ of invariants of positive degree. This algebra is naturally graded and thus a graded KG-module. The fake degree of a K-representation phi of G is the multiplicity of the dual of phi in this module.

    For a reflection group in characteristic zero there is a simple formula for the fake degrees.
*/


//============================================================================
declare attributes GrpMat:
    FakeDegrees, //The fake degrees
    PhiNames; //The (d,b)-pairs of the ordinary representations of a matrix group.

//============================================================================
intrinsic FakeDegree(chi::AlgChtrElt : UseFormula:=true, UseDB:=true) -> RngUPolElt
{
	Computes the fake degree of the character chi of a matrix group G over a field of characteristic zero.
}
    G := Group(Parent(chi));
    if Characteristic(BaseRing(G)) ne 0 then
    	error "The group has to be defined over a field of characteristic zero (as is the character).";
    end if;

    if not IsIrreducible(chi) then
    	error "Character has to be irreducible.";
    end if;

    if UseDB and assigned G`DBDir and CHAMP_ExistsInDB(G`DBDir, "Invariants/FakeDegrees") then
        CharacterTable(~G);
        vprint RngInvar, 5: "(FakeDegrees). Loaded from DB.";
        G`FakeDegrees := CHAMP_GetFromDB(G`DBDir, "Invariants/FakeDegrees");
        return G`FakeDegrees[Position(G`CharacterTable, chi)];
    end if;

    K := RationalFunctionField(BaseRing(G));
    P<q> := PolynomialRing(Integers());

    IsNonModular(~G);
    IsReflectionGroup(~G);
    InvariantRing(~G);

    /* We use the formula in case G is a reflection group in characteristic zero */
    if G`IsReflectionGroup and UseFormula then
        Classes(~G);
        Degrees(~G);//it does not matter if we use K[V] or K[V^*] in this case!
        //formula in Opdam and Geck-Malle
        chid:=ComplexConjugate(chi);
        f := P!Numerator(1/Order(G) * ArraySum([ G`Classes[i][2]*(K!chid(ClassRepresentative(G,i)))/( Determinant( 1-ChangeRing(Matrix(ClassRepresentative(G,i)), K)*q )) : i in [1..#G`Classes] ])*ArrayProduct([1-K.1^d : d in G`Degrees]));
        return f;
    else
        error "Not implemented yet.";
    end if;

end intrinsic;

//============================================================================
intrinsic FakeDegrees(~G::GrpMat : Method := "Formula", SaveToDB:=false, UseDB:=true)
{
	Computes the fake degrees of all absolutely irreducible representations (stored in Grp`Representations) and attaches them to the corresponding attribute. If K is of characteristic zero and G is a reflection group, there is an easy formula for this. If in this case Method is "Formula" (Default), this formula is used. Otherwise, the fake degrees will be computed directly as defined.
}
    if assigned G`FakeDegrees then
        return;
    end if;

    if not Method eq "Direct" and UseDB and assigned G`DBDir and CHAMP_ExistsInDB(G`DBDir, "Invariants/FakeDegrees") then
    	if Characteristic(BaseRing(G)) eq 0 then
    		CharacterTable(~G);
    	end if;
        G`FakeDegrees := CHAMP_GetFromDB(G`DBDir, "Invariants/FakeDegrees");
        return;
    end if;

    if Method eq "Direct" then

        //computes the multiplicities <K[V]_G,M^*>
        CoinvariantAlgebraGradedGModule(~G);
        dec := DecompositionInGradedGrothendieckGroup(G`CoinvariantAlgebraGradedGModule);
        p := Characteristic(BaseRing(G));
        RepresentationsDualityInvolution(~G, p);
        G`FakeDegrees := [ dec[G`RepresentationsDualityInvolution[p][i]] : i in [1..#G`Representations[p]] ];

    elif Method eq "Formula" then

        if Characteristic(BaseRing(G)) eq 0 then
            IsReflectionGroup(~G);
            if G`IsReflectionGroup then
                IsReflectionGroup(~G);
                Classes(~G);
                InvariantRing(~G);
                Degrees(~G);
                CharacterTable(~G);
                G`FakeDegrees := [ FakeDegree(G`CharacterTable[i]) : i in [1..#G`CharacterTable] ];
            else
                FakeDegrees(~G: Method:="Direct");
            end if;

        else
            FakeDegrees(~G: Method:="Direct");
        end if;

    end if;

end intrinsic;

//============================================================================
intrinsic FakeDegrees(G::GrpMat : Method:="Formula") -> SeqEnum
{}

    FakeDegrees(~G:Method:=Method);
    return G`FakeDegrees;

end intrinsic;

//============================================================================
intrinsic PhiNames(~G::GrpMat : Method:="Formula")
{
	The phi-name of an absolutely irreducible K-representation phi of a K-matrix group G is the (d,b)-pair of phi, where d is the degree of phi and b is the valuation of the fake degree of phi. The option Method is for the fake degree computation.
}

    if assigned G`PhiNames then
        return;
    end if;

    p := Characteristic(BaseRing(G));

    if p eq 0 then
    	CharacterTable(~G);
    	FakeDegrees(~G : Method:=Method);
    	G`PhiNames := [ "\\phi_{"*Sprint(G`CharacterTable[i](1))*","*Sprint(Valuation(G`FakeDegrees[i]))*"}" : i in [1..#G`CharacterTable] ];
    else
    	FakeDegrees(~G: Method:=Method);
    	Modules(~G,p);
    	G`PhiNames := [ "\\phi_{"*Sprint(Dimension(G`Modules[p][i]))*","*Sprint(Valuation(G`FakeDegrees[i]))*"}" : i in [1..#G`Modules[p]] ];
    end if;

end intrinsic;
